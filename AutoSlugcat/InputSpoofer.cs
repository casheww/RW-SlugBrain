using System.Collections.Generic;
using UnityEngine;

namespace SlugBrain
{
    class InputSpoofer
    {
        public InputSpoofer(int bufferSize = 128)
        {
            capacity = bufferSize;
            _buffer = new Player.InputPackage[capacity];
            _front = -1;
            _rear = -1;
            Count = 0;
        }

        /// <summary>
        /// Combines automated inputs registered via <see cref="PushInputPackages"/>
        /// with player inputs. Can also be used for combining sets of auto inputs.
        /// </summary>
        /// <param name="orig">Inputs generated by the player.</param>
        public Player.InputPackage ModifyInput(Player.InputPackage orig)
        {
            Player.InputPackage newPackage;

            if (!IsEmpty)
            {
                newPackage = CombineInputs(orig, _buffer[_front]);

                Front++;        // move up the front of the buffer/queue
                Count--;
            }
            else newPackage = new Player.InputPackage();

            return newPackage;
        }

        /// <summary>
        /// Registers automated inputs to be combined with player inputs. <br/>
        /// Each item the inputs array should represent the input package for x frames in the future,
        /// where x is the index of the item. 
        /// </summary>
        public void PushInputPackages(Player.InputPackage[] inputs)
        {
            for (int i = 0; i < inputs.Length; i++)
            {
                if (i >= capacity)
                {
                    BrainPlugin.Log("Input buffer capacity reached!", error: true);
                    break;
                }

                if (IsEmpty)
                {
                    Front = 0;
                    Rear = 1;
                }

                _buffer[Front + i] = CombineInputs(_buffer[Front + i], inputs[i]);

                // check if we are adding new input frames
                //  (rather than just merging with frames that already exist in the buffer)
                if (i == Rear)
                {
                    Rear++;
                    Count++;
                }
            }
        }

        private static Player.InputPackage CombineInputs(Player.InputPackage in0, Player.InputPackage in1)
        {
            in0.x = Mathf.Clamp(in0.x + in1.x, -1, 1);
            in0.y = Mathf.Clamp(in0.y + in1.y, -1, 1);

            in0.jmp = in0.jmp || in1.jmp;
            in0.mp = in0.mp || in1.mp;
            in0.pckp = in0.pckp || in1.pckp;
            in0.thrw = in0.thrw || in1.thrw;

            return in0;
        }


        private readonly Player.InputPackage[] _buffer;

        private int Front
        {
            get => _front;
            set => _front = value < capacity ? value : capacity - value;
        }
        private int _front;

        private int Rear
        {
            get => _rear;
            set => _rear = value < capacity ? value : capacity - value;
        }
        private int _rear;
        
        public readonly int capacity;
        public int Count { get; private set; }
        public bool IsEmpty => Count == 0;
        public bool IsFull => Count == capacity;

    }
}
